{
  "@context": "https://linked.art/ns/v1/linked-art.json",
  "id": "https://example.org/cdkg/LinguisticObject/presentation/8",
  "type": "LinguisticObject",
  "_label": "Textual content of \"Humans and the Graph - Inspiring and empowering GraphQL adoption\"",
  "classified_as": [
    {
      "id": "http://vocab.getty.edu/aat/300027388",
      "type": "Type",
      "_label": "Transcript"
    }
  ],
  "content": "Hi, everyone. My name is Dan Boerner, and I champion the graph at Apollo. And in this talk, I wanted to share my thoughts about the human side of GraphQL by focusing on the people involved with adopting the technology, their motivations, objectives, and how they're managing the change from a traditional point to point API to a query based unified graph. Now everything I share today comes from what we've learned from others that are evangelizing and championing the use of GraphQL in their organizations, and you can see their logos on the screen here. And I'd like to give special thanks to the panelists shown here who joined from Netflix, Zillow, and Dava and Expedia recently to discuss this very topic at a recent GraphQL summit roundtable. And if you're interested in hearing a great interactive discussion on this topic, you can find a recording at the link below or by visiting summit dot graph q l dot com. Now anytime I see an exponential adoption curve, I think about the underlying motivations that are driving the change. In this case, the curve shows the number of downloads of Apollo's open source GraphQL client over time. And this is a helpful proxy for overall GraphQL adoption. I think the curve makes a strong argument that GraphQL is one of the biggest innovations in API technology in our generation. So it's worth first to understand what's going on. What's driving this adoption? And while I think like other innovations, cloud native computing, containerization, reactive programming, it's natural to try to explain the rapid adoption from a technical point of view by focusing on how this new innovation is better than the old in various technical aspects. Now we'll get into a few of the technical benefits of GraphQL in a moment, but I think that focusing on the technical benefits alone leaves out a big part of why any of these innovations take root and spread quickly. And I I think that's because successful innovations provide better solutions to problems that people face, to teams face, to human problems. And those solutions help them build their products and bring them to market, and that's what really drives the change. Now in my career, I've been involved with a number of large scale tech adoption efforts and some of which have been more successful than others. And I have two observations. One, widespread adoption of any new technology is very difficult and time consuming. And most adoption efforts, frankly, don't succeed. They don't reach their goals. And my hypothesis is that it's only innovation that solve both technical and human problems that justify the large amount of time and effort required to successfully see them spread across the enterprise. Without that return on effort, the initiatives fade, and they fall short of their original goals. And let's see if we can tease out why that might be so by answering a few questions. What is motivating, in this case, a fundamental change to our API stack? What resistance do we face and do we encounter when we try to make this change and why? And in face of that resistance, how can we create space and safety so that that change can happen and can be absorbed? Let's begin first with motivations and and the problems that GraphQL solves. Now from a simplistic tactical point of view, GraphQL is essentially defined by three things. It's an API query language. Much like SQL queries databases, you can use GraphQL to query across APIs. Now, secondly, it's a stable, strongly typed, declarative API contract, which is captured in a schema definition language or SDL file. And third, it's a runtime system. Right? There's a client library, gateway, and server to make and process requests, to route them to their underlying services or data layers, and then to return composed responses back to the client. And GraphQL solves a large number of technical problems, and they're well understood, and they're well explained in many talks and and resources online. So I won't dwell on them today other than to say that I think they're very compelling, and a lot of companies find them compelling. But if we want to have a widespread and successful adoption of GraphQL across the whole enterprise, let's check-in with our hypothesis. And it tells us that we need to solve both technical and human problems. So let's look at what kind of human problems exist in our typical service oriented architecture. Now I'll start with the viewpoint of an application or a front end team. And this wealth of service APIs and data reminds me of the phrase, water, water everywhere, but not a drop to drink. Because in order to build products from all those experiences, to build experiences from services, I should say, those application teams have to integrate with many different APIs. They have to deal with many API versions. They have to configure API endpoints, learn about different API idioms and syntaxes, and orchestrate multiple calls together. And as a result, a lot of logic gets built into the clients, into the front ends. And if that was done once, that might be okay, but it's not. That logic is duplicated into each application or each front end, and that duplication causes two serious problems for people. One, for internal product teams, all that duplicated logic means each new experience or product feature has to be built multiple times, slowing innovation. For customers, it leads to a fragmented customer experience when they use different clients or devices. And this fragmentation is leading to frustration and a dizzying amount of difference for differences' sake. We see this across experiences all over across the web and applications across all industries. Expedia, for example, had this problem, and they turned to the graph to unify their customer experience. And they coupled a unified graph, a design system, and a component architecture to create a unified customer experience across all their touch points. And you can see the benefits that their team called out with this approach. But it's not just travel. In retail, Walmart turned to the graph to create a seamless shopping experience across their online and in store applications, which had previously been completely separate and accessed through separate tabs in the user interface. With a unified graph, they were able to unify and create a seamless customer experience across web, iOS, and Android in record time, just in time for Black Friday. So you can enjoy this experience by visiting Walmart today. And those are just two examples of problems faced by customers and application teams. But what about service teams? Well, this might be a view from the services team perspective Managing all of those connections, all of those client dependencies is time consuming. Managing the different versions, convincing clients to upgrade to new ones, or hopefully to deprecate and move off very old ones, it's all overhead. Not to mention requests from enterprise architecture teams or IT to unify on, say, an API gateway. It can feel very overwhelming, and it leaves very little time to focus on improving their services' underlying functionality or performance, let alone the cost of the occasional need to architect completely their service. But what's worse, even if they do these things, it still pushes all that complexity down to each client where it gets duplicated. So many teams have built front end APIs in the back end for front end pattern to simplify the complexity Steam quickly Steam quickly. So more human problems. We've got version and API endpoint management, direct coordination between apps and service teams, duplication of logic, slowing experimentation, and new feature rollout. So let's briefly turn to how GraphQL addresses these very real real and very human problems. First on the left, it's an API built for building products. It's freed from managing service endpoints and orchestration. App development teams can focus on experiences, not integration. Second, it's a query language that's tailored for use. Apps pick what they need from a shared common contract, optimizing performance and removing complexity from each application. Third, in the middle, the unified representation of your services, data, and digital capabilities is created, each capability is expressed as declarative abstract contract via schema and unified together into a composed super graph schema. Now an insulating layer is the fourth step. On the service side, on the right side, decoupled from those direct app client dependencies, service teams can focus on optimizing their capabilities and architecture without fear of breaking changes, and they can even reimplement their architecture behind a safe typed contract without even letting their clients know. And that technical architecture empowers new collaboration models as well. On the left, app teams bring their understanding of the customer problem, the customer experience, and what's needed to build it. On the right, service teams bring their domain declarative, strongly strongly typed, abstract schema contract that once built allows each team to focus on what they do best. And then revising the schema contract as needed in a lightweight, backwards compatible manner, thanks to automatic schema and composition checks offered by Apollo's graph platform. Now this sounds fantastic. No? Everyone's working together to leverage a new API paradigm and technology to get more done with less hassle. But it's a big change, isn't it? Service teams and front end teams coming together design an API doesn't happen overnight. So let's let's see what changes that that provokes. And As much as we'd like to think that we're hyperrational beings who evaluate the merits of each new technology, logically, it turns out we're people. We're human. And humans have an innate tendency to minimize threats and seek safety. And, commonly, we see major tech changes like GraphQL provoke some of these triggers. Fairness. My hard fought skills, are they gonna be made obsolete? Is everything changing? I have no certainty. Am I losing control? Are others now telling me what my service what my team should be doing, what good is? That affects my sense of autonomy. Now in the recent roundtable I hosted, Steven Spalding of Netflix noted that these triggers are actually biological in nature. Nature. They're identified by our amygdala as a survival mechanism. And our lizard bean brain actually tells us to run away from some of these proposed tactical changes before a rational engineering mind has even gotten a chance to consider them, or worse, to fight back with every argument we can find. Now it's perfectly natural to think that we can just dispassionately compare the benefits of a query language or a new server architecture. But it turns out we need to identify and address the human triggers that are happening along the way. And that's not intuitive, is it? Because as an evangelist of an innovation , when I trigger a fight or flight response in someone I'm trying to convince, what what's my response? Well, it's only to push harder, to fight back with fresh arguments or to give chase, essentially attacking them with believe me, believe me. And that just makes it worse. That just creates more triggers. So if change necessarily triggers base emotions in those we seek to convince, what can we do? Is there a way to avoid this conflict and avoid these triggers? Well, I wish I could say I believe there was, but we discussed this topic in the roundtable, and we all came to the same conclusion. Friction or conflict is just another word for interaction. All big leaps come from a controlled amount of struggle and friction. And second, diversity of thought is the source of insight. It's not to be avoided. Knowing where your blind spots are, knowing what you don't even know you don't know is crucial to making discoveries. And third, avoiding conflict via path of least resistance isn't healthy in relationships, and it's not healthy in system design. It leads to extra layers and complexity being built to avoid the need to come together and reconcile those differences. So, again, great. What do we do then? If friction and conflict are inevitable and they're not to be avoided, what can or what should we do to manage that change and the reactions that come about? Well, let's talk about a few tools that you can use to promote that positive friction that we talk about. Broadly speaking, there's four that I'll share with you today. The first is empathy. Rather than forcing a solution on others because it's technically better, try adopting a product mindset and work to figure out your customer's problems, the problem that the adopting teams have. By thinking and talking in terms of other people's interests, what they care about, we gain empathy, and that leads to trust. And trust is what we need to encourage change and work through fear and doubt. Second, shift attention to common outcomes. The best way to find common ground is not to technically crush any doubt or push back with the awesome force of your will and persuasion. That energy only increases resistance to new ideas. But rather, redirect to discussion of common outcomes that you all seek. It's very difficult to align on approach if you don't have alignment on your goals, and the more agreement on outcomes, the easier it is to explore solutions that meet those needs. Third, demonstrate versus scold. When we want new behavior, we can demand it, we can criticize noncompliance or resistance, or we can demonstrate and show its value. And often, this means actually rolling up your sleeves and working with those adopting teams. Putting skin in the game not only shows your commitment to outcomes, but helps you understand where changes are needed to your current approach. So adopting a show and tell approach with the emphasis on show is a practical tool you can use. And finally, and perhaps most importantly, embrace new mindsets. At Apollo, we've seen many companies adopt GraphQL at scale across our organization, and we've observed a very natural instinct to see the new in terms of the familiar. I mean, we've been doing APIs as a community, right, for a long time. So adding a query language across multiple APIs, that's great, but the shape and the purpose of every API, that doesn't need to change, does it? Well, our experience has been that when you take that approach, when you try to fit the new into the old, you often miss out on much of the value of the change. And in the case of APIs, there's a strong consensus now about the power and importance of designing with an API first mindset. Right? But if we look a little deeper, if those APIs are designed for each service by each service team independently and they reflect only the view point of view of the service owner, then they're in a sense thrown over the wall to the front end. And while consuming multiple of them in a single query is mechanically better, it doesn't really address the complexity problem. Whereas, if we adopt a true customer mindset for APIs, we see we need a connected set of APIs, a graph shaped for use by its clients, not its underlying services. And designing such an interconnected graph requires a much deeper level of collaboration, doesn't it? And that pulls our teams together to build something that truly captures, something long lasting, something durable. And that's an evolving API contract that offers a unified and interconnected set of data and capabilities built upon but abstracted away from the underlying service and data laters. And that's just more valuable than enabling queries. So let's talk about a few takeaways to summarize the topics that we've covered today. First, tech adoption is a human endeavor. If your organization is adopting GraphQL, your people are dealing with change. And along with the benefits, the value of new technologies such as GraphQL, change often triggers resistance. Constructive friction is needed to advance, to make the leaps. To avoid change is a siren's call to the rocks. It sounds attractive to avoid it, but, ultimately, it's destructive. Rather, by practicing empathy, shifting focus, demonstrating success, and adopting new mindsets, you can create a healthy space for change and healthy conflict. And, ultimately, and this is borne out over across a hundred or so companies that we've talked to about GraphQL adoption. Human factors affect the success of tech adoption more than tactical factors do. And that's the end of our talk today. I wanna thank Connected Data World for this opportunity to reach you today and to you for watching the presentation. For more content on GraphQL, the unified graph, Apollo's graph platform, and more about how companies can get the most value out of adopting GraphQL, please visit our site, our YouTube channel. And if you wanna continue the conversation directly with me, please reach out via Twitter or the email addresses here. And thank you.",
  "language": [
    {
      "id": "http://vocab.getty.edu/aat/300388277",
      "type": "Language",
      "_label": "English"
    }
  ],
  "created_by": {
    "id": "https://example.org/cdkg/Creation/presentation/8",
    "type": "Creation",
    "caused_by": [
      {
        "id": "https://example.org/cdkg/Activity/presentation/8",
        "type": "Activity",
        "_label": "Presentation of \"Humans and the Graph - Inspiring and empowering GraphQL adoption\""
      }
    ]
  },
  "digitally_carried_by": [
    {
      "id": "https://example.org/cdkg/DigitalObject/recording/8",
      "type": "DigitalObject",
      "_label": "Recording of \"Humans and the Graph - Inspiring and empowering GraphQL adoption\""
    }
  ]
}